// 1. User Entity
@Entity
@Table(name = "users")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(unique = true)
    private String username;
    
    private String password;
    
    @Enumerated(EnumType.STRING)
    private Role role;
    
    // constructors, getters, setters
    public User() {}
    
    public User(String username, String password, Role role) {
        this.username = username;
        this.password = password;
        this.role = role;
    }
    
    // getters and setters...
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    
    public String getUsername() { return username; }
    public void setUsername(String username) { this.username = username; }
    
    public String getPassword() { return password; }
    public void setPassword(String password) { this.password = password; }
    
    public Role getRole() { return role; }
    public void setRole(Role role) { this.role = role; }
}

// 2. Role Enum
public enum Role {
    ADMIN,
    NURSE,
    USER
}

// 3. Session Entity
@Entity
@Table(name = "user_sessions")
public class UserSession {
    @Id
    private String sessionToken;
    
    @ManyToOne
    @JoinColumn(name = "user_id")
    private User user;
    
    private LocalDateTime createdAt;
    private LocalDateTime expiresAt;
    
    public UserSession() {}
    
    public UserSession(String sessionToken, User user, LocalDateTime expiresAt) {
        this.sessionToken = sessionToken;
        this.user = user;
        this.createdAt = LocalDateTime.now();
        this.expiresAt = expiresAt;
    }
    
    // getters and setters...
    public String getSessionToken() { return sessionToken; }
    public void setSessionToken(String sessionToken) { this.sessionToken = sessionToken; }
    
    public User getUser() { return user; }
    public void setUser(User user) { this.user = user; }
    
    public LocalDateTime getCreatedAt() { return createdAt; }
    public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; }
    
    public LocalDateTime getExpiresAt() { return expiresAt; }
    public void setExpiresAt(LocalDateTime expiresAt) { this.expiresAt = expiresAt; }
    
    public boolean isExpired() {
        return LocalDateTime.now().isAfter(expiresAt);
    }
}

// 4. Repositories
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByUsername(String username);
}

@Repository
public interface UserSessionRepository extends JpaRepository<UserSession, String> {
    Optional<UserSession> findBySessionToken(String sessionToken);
    void deleteByUser(User user);
}

// 5. Authentication Service
@Service
public class AuthService {
    
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private UserSessionRepository sessionRepository;
    
    @Autowired
    private PasswordEncoder passwordEncoder;
    
    public String login(String username, String password) {
        Optional<User> userOpt = userRepository.findByUsername(username);
        
        if (userOpt.isEmpty()) {
            throw new RuntimeException("Invalid credentials");
        }
        
        User user = userOpt.get();
        if (!passwordEncoder.matches(password, user.getPassword())) {
            throw new RuntimeException("Invalid credentials");
        }
        
        // Delete existing sessions for this user
        sessionRepository.deleteByUser(user);
        
        // Create new session
        String sessionToken = UUID.randomUUID().toString();
        LocalDateTime expiresAt = LocalDateTime.now().plusHours(24); // 24 hour session
        
        UserSession session = new UserSession(sessionToken, user, expiresAt);
        sessionRepository.save(session);
        
        return sessionToken;
    }
    
    public void logout(String sessionToken) {
        sessionRepository.deleteById(sessionToken);
    }
    
    public User validateSession(String sessionToken) {
        Optional<UserSession> sessionOpt = sessionRepository.findBySessionToken(sessionToken);
        
        if (sessionOpt.isEmpty()) {
            return null;
        }
        
        UserSession session = sessionOpt.get();
        if (session.isExpired()) {
            sessionRepository.delete(session);
            return null;
        }
        
        return session.getUser();
    }
}

// 6. Security Configuration
@Configuration
@EnableWebSecurity
@EnableMethodSecurity(prePostEnabled = true)
public class SecurityConfig {
    
    @Autowired
    private AuthService authService;
    
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .csrf(csrf -> csrf.disable())
            .sessionManagement(session -> session
                .sessionCreationPolicy(SessionCreationPolicy.STATELESS))
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/auth/login", "/auth/register").permitAll()
                .requestMatchers("/admin/**").hasRole("ADMIN")
                .requestMatchers("/nurse/**").hasAnyRole("ADMIN", "NURSE")
                .requestMatchers("/user/**").hasAnyRole("ADMIN", "NURSE", "USER")
                .anyRequest().authenticated())
            .addFilterBefore(new SessionAuthenticationFilter(authService), 
                           UsernamePasswordAuthenticationFilter.class);
        
        return http.build();
    }
}

// 7. Custom Authentication Filter
public class SessionAuthenticationFilter extends OncePerRequestFilter {
    
    private final AuthService authService;
    
    public SessionAuthenticationFilter(AuthService authService) {
        this.authService = authService;
    }
    
    @Override
    protected void doFilterInternal(HttpServletRequest request, 
                                  HttpServletResponse response, 
                                  FilterChain filterChain) throws ServletException, IOException {
        
        String sessionToken = request.getHeader("Authorization");
        
        if (sessionToken != null && sessionToken.startsWith("Bearer ")) {
            sessionToken = sessionToken.substring(7);
            
            User user = authService.validateSession(sessionToken);
            
            if (user != null) {
                List<SimpleGrantedAuthority> authorities = List.of(
                    new SimpleGrantedAuthority("ROLE_" + user.getRole().name())
                );
                
                UsernamePasswordAuthenticationToken authentication = 
                    new UsernamePasswordAuthenticationToken(user.getUsername(), null, authorities);
                
                SecurityContextHolder.getContext().setAuthentication(authentication);
            }
        }
        
        filterChain.doFilter(request, response);
    }
}

// 8. Authentication Controller
@RestController
@RequestMapping("/auth")
public class AuthController {
    
    @Autowired
    private AuthService authService;
    
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private PasswordEncoder passwordEncoder;
    
    @PostMapping("/login")
    public ResponseEntity<?> login(@RequestBody LoginRequest request) {
        try {
            String sessionToken = authService.login(request.getUsername(), request.getPassword());
            return ResponseEntity.ok(new LoginResponse(sessionToken, "Login successful"));
        } catch (Exception e) {
            return ResponseEntity.status(401).body(new ErrorResponse("Invalid credentials"));
        }
    }
    
    @PostMapping("/logout")
    public ResponseEntity<?> logout(HttpServletRequest request) {
        String sessionToken = request.getHeader("Authorization");
        if (sessionToken != null && sessionToken.startsWith("Bearer ")) {
            sessionToken = sessionToken.substring(7);
            authService.logout(sessionToken);
        }
        return ResponseEntity.ok(new MessageResponse("Logged out successfully"));
    }
    
    @PostMapping("/register")
    public ResponseEntity<?> register(@RequestBody RegisterRequest request) {
        if (userRepository.findByUsername(request.getUsername()).isPresent()) {
            return ResponseEntity.badRequest().body(new ErrorResponse("Username already exists"));
        }
        
        User user = new User(
            request.getUsername(),
            passwordEncoder.encode(request.getPassword()),
            request.getRole()
        );
        
        userRepository.save(user);
        return ResponseEntity.ok(new MessageResponse("User registered successfully"));
    }
}

// 9. Request/Response DTOs
class LoginRequest {
    private String username;
    private String password;
    
    // getters and setters
    public String getUsername() { return username; }
    public void setUsername(String username) { this.username = username; }
    
    public String getPassword() { return password; }
    public void setPassword(String password) { this.password = password; }
}

class RegisterRequest {
    private String username;
    private String password;
    private Role role;
    
    // getters and setters
    public String getUsername() { return username; }
    public void setUsername(String username) { this.username = username; }
    
    public String getPassword() { return password; }
    public void setPassword(String password) { this.password = password; }
    
    public Role getRole() { return role; }
    public void setRole(Role role) { this.role = role; }
}

class LoginResponse {
    private String sessionToken;
    private String message;
    
    public LoginResponse(String sessionToken, String message) {
        this.sessionToken = sessionToken;
        this.message = message;
    }
    
    // getters
    public String getSessionToken() { return sessionToken; }
    public String getMessage() { return message; }
}

class ErrorResponse {
    private String error;
    
    public ErrorResponse(String error) {
        this.error = error;
    }
    
    public String getError() { return error; }
}

class MessageResponse {
    private String message;
    
    public MessageResponse(String message) {
        this.message = message;
    }
    
    public String getMessage() { return message; }
}

// 10. Example Protected Controllers
@RestController
@RequestMapping("/admin")
public class AdminController {
    
    @GetMapping("/users")
    public ResponseEntity<?> getAllUsers() {
        // Only accessible by ADMIN
        return ResponseEntity.ok("Admin: All users data");
    }
    
    @DeleteMapping("/users/{id}")
    public ResponseEntity<?> deleteUser(@PathVariable Long id) {
        // Only accessible by ADMIN
        return ResponseEntity.ok("Admin: User deleted");
    }
}

@RestController
@RequestMapping("/nurse")
public class NurseController {
    
    @GetMapping("/patients")
    public ResponseEntity<?> getPatients() {
        // Accessible by ADMIN and NURSE
        return ResponseEntity.ok("Nurse/Admin: Patients data");
    }
    
    @PostMapping("/records")
    public ResponseEntity<?> createRecord(@RequestBody Object record) {
        // Accessible by ADMIN and NURSE
        return ResponseEntity.ok("Nurse/Admin: Record created");
    }
}

@RestController
@RequestMapping("/user")
public class UserController {
    
    @GetMapping("/profile")
    public ResponseEntity<?> getProfile() {
        // Accessible by ADMIN, NURSE, and USER
        return ResponseEntity.ok("User profile data");
    }
    
    @PutMapping("/profile")
    public ResponseEntity<?> updateProfile(@RequestBody Object profile) {
        // Accessible by ADMIN, NURSE, and USER
        return ResponseEntity.ok("Profile updated");
    }
}